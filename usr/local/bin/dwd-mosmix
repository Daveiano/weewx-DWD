#!/usr/bin/python3
# Wettervorhersage
# Copyright (C) 2022 Johanna Roedenbeck
# licensed under the terms of the General Public License (GPL) v3

from __future__ import absolute_import
from __future__ import print_function
from __future__ import with_statement

"""
    This script is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This script is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
"""

"""
   station list see:
   https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/mosmix_stationskatalog.cfg?view=nasPublication&nn=16102
   
"""

import json
import time
import datetime
import configobj
import os.path
import requests
import csv
import io
import urllib.parse
from email.utils import formatdate
import html.parser
import zipfile

if __name__ == "__main__":
    import optparse
    import sys
    def loginf(x):
        print(x, file=sys.stderr)
    def logerr(x):
        print(x, file=sys.stderr)


DEFAULT_LOCAL_FORECAST_URL = "https://opendata.dwd.de/weather/local_forecasts"

LOCATION_DICT = {
  'Döbeln':'P0291',
  'Wurzen':'P0292',
  'Delitzsch':'EW005',
  'Leipzig':'10471',
  'Oschatz':'10480',
  'Dresden':'10487',
  'Chemnitz':'10577',
  'Fichtelberg':'10578'}

MOSMIX_DICT = {
  'l':'MOSMIX_L',
  's':'MOSMIX_S'}

OBS_DICT = {
  'FF': lambda x: x*3.6,
  'PPPP':lambda x: x*0.01,
  'T5cm':lambda x: x-273.15,
  'Td':lambda x: x-273.15,
  'TG':lambda x: x-273.15,
  'TM':lambda x: x-273.15,
  'TN':lambda x: x-273.15,
  'TTT':lambda x: x-273.15,
  'TX':lambda x: x-273.15}
  
def get_mos_url(location, mosmix):
    if location:
        location = LOCATION_DICT.get(location,location)
        location = "single_stations/%s/kml/MOSMIX_L_LATEST_%s.kmz" % (location,location)
    else:
        location = "all_stations/kml/MOSMIX_L_LATEST.kmz"
    return DEFAULT_LOCAL_FORECAST_URL+'/'+"mos"+"/"+MOSMIX_DICT.get(mosmix.lower(),mosmix)+"/"+location

WW_LIST = [
    (95,'leichtes oder mäßiges Gewitter mit Regen oder Schnee','slight or moderate thunderstorm with rain or snow',1,'thunderstorm.png'),
    (57,'mäßiger oder starker gefrierender Sprühregen','Drizzle, freezing, moderate or heavy (dence)',2,'sleet.png'),
    (56,'leichter gefrierender Sprühregen','Drizzle, freezing, slight',3,'sleet.png'),
    (67,'mäßiger bis starker gefrierender Regen','Rain, freezing, moderate or heavy (dence)',4,'sleet.png'),
    (66,'leichter gefrierender Regen','Rain, freezing, slight',5,'sleet.png'),
    (86,'mäßiger bis starker Schneeschauer','Snow shower(s), moderate or heavy',6,'snow.png'),
    (85,'leichter Schneeschauer','Snow shower(s), slight',7,'snow.png'),
    (84,'mäßiger oder starker Schneeregenschauer','Shower(s) of rain and snow mixed, moderate or heavy',8,'sleet.png'),
    (83,'leichter Schneeregenschauer','Shower(s) of rain and snow mixed, slight',9,'sleet.png'),
    (82,'äußerst heftiger Regenschauer','extremely heavy rain shower',10,'rain.png'),
    (81,'mäßiger oder starker Regenschauer','moderate or heavy rain showers',11,'rain.png'),
    (80,'leichter Regenschauer','slight rain shower',12,'rain.png'),
    (75,'durchgehend starker Schneefall','heavy snowfall, continuous',13,'snow.png'),
    (73,'durchgehend mäßiger Schneefall','moderate snowfall, continuous',14,'snow.png'),
    (71,'durchgehend leichter Schneefall','slight snowfall, continuous',15,'snow.png'),
    (69,'mäßger oder starker Schneeregen','moderate or heavy rain and snow',16,'sleet.png'),
    (68,'leichter Schneeregen','slight rain and snow',17,'sleet.png'),
    (55,'durchgehend starker Sprühregen','heavy drizzle, not freezing, continuous',18,'drizzle.png'),
    (53,'durchgehend mäßiger Sprühregen','moderate drizzle, not freezing, continuous',19,'drizzle.png'),
    (51,'durchgehend leichter Sprühregen','slight drizzle, not freezing, continuous',20,'drizzle.png'),
    (65,'durchgehend starker Regen','heavy rain, not freezing, continuous',21,'rain.png'),
    (63,'durchgehend mäßiger Regen','moderate rain, not freezing, continuous',22,'rain.png'),
    (61,'durchgehend leichter Regen','slight rain, not freezing, continuous',23,'rain.png'),
    (49,'Nebel mit Reifansatz, Himmel nicht erkennbar, unverändert','Ice Fog, sky not recognizable',24,'fog.png'),
    (45,'Nebel, Himmel nicht erkennbar','Fog, sky not recognizable',25,'fog.png'),
    (3,'Bewölkung zunehmend','Clouds generally forming or developing',26,None),
    (2,'Bewölkung unverändert','State of sky on the whole unchanged',27,None),
    (1,'Bewölkung abnehmend','Clouds generally dissolving or becoming less developed',28,None),
    (0,'keine Bewölkungsentwicklung','no cloud cover development',29,None)]

N_ICON_LIST = [
    ('clear-day.png','clear-night.png'),
    ('mostly-clear-day.png','mostly-clear-night.png'),
    ('partly-cloudy-day.png','partly-cloudy-night.png'),
    ('mostly-cloudy-day.png','mostly-cloudy-night.png'),
    ('cloudy.png','cloudy.png')]
    
def get_ww(ww,n,night):
    for ii in WW_LIST:
        if ii[0] in ww:
            wwcode = ii
            break
    else:
        wwcode = (0,'','',30)
    if wwcode[0]<=3:
        night = 1 if night else 0
        if n<6.25:
            icon = N_ICON_LIST[0][night]
        elif n<31.25:
            icon = N_ICON_LIST[1][night]
        elif n<68.75:
            icon = N_ICON_LIST[2][night]
        elif n<93.75:
            icon = N_ICON_LIST[3][night]
        else:
            icon = N_ICON_LIST[4][0]
        wwcode = (wwcode[0],wwcode[1]+' '+str(n),wwcode[2]+' '+str(n),wwcode[3],icon)
    return wwcode
    
class KmlParser(html.parser.HTMLParser):

    def __init__(self, log_tags=False):
        super(KmlParser,self).__init__()
        self.log_tags = log_tags
        self.lvl = 0
        self.tags = []
        self.mos = dict()
        self.ar = [self.mos]
        self.placemark = None
        self.forecastelement = None
        
    @staticmethod
    def _mktime(timestring):
        """ convert CAP timestamp string to epoch time """
        if timestring[-1]=='Z':
            timestring = timestring.replace('Z','+0000')
        idx = timestring.find('.')
        if idx>=0:
            idx2 = timestring.find('+')
            if idx2==-1: idx2 = timestring.find('-')
            timestring = timestring[:idx]+timestring[idx2:]
        ti = datetime.datetime.strptime(timestring,'%Y-%m-%dT%H:%M:%S%z')
        #print(ti)
        return int(ti.timestamp()*1000)

    def handle_starttag(self, tag, attrs):
        if self.log_tags:
            print(self.lvl,self.tags,'start',tag,attrs)
        self.tags.append(tag)
        self.lvl+=1
        if tag=='dwd:model' and self.tags[-2]=='dwd:referencedmodel':
            self.mos['ReferenceModel'] = dict()
            for ii in attrs:
                if ii[0]=='dwd:name':
                    self.mos['ReferenceModel']['name'] = ii[1]
                elif ii[0]=='dwd:referencetime':
                    self.mos['ReferenceModel']['ReferenceTime'] = KmlParser._mktime(ii[1])
        if tag=='kml:placemark':
            if 'Placemark' not in self.mos:
                self.mos['Placemark'] = []
            if self.placemark:
                self.mos['Placemark'].append(self.placemark)
            self.placemark = dict()
        if tag=='dwd:forecast':
            for ii in attrs:
                if ii[0]=='dwd:elementname':
                    self.forecastelement = ii[1]
        
    def handle_endtag(self, tag):
        del self.tags[-1]
        self.lvl-=1
        if tag=='kml:placemark' and self.placemark:
            if 'Placemark' not in self.mos:
                self.mos['Placemark'] = []
            self.mos['Placemark'].append(self.placemark)
            self.placemark = None
        self.forecastelement = None
        if self.log_tags:
            print(self.lvl,self.tags,'end',tag)
       
    def handle_data(self, data):
        if len(self.tags)>0:
            tag = self.tags[-1]
            if self.placemark is not None:
                # inside a kml:Placemark section
                if tag=='kml:name':
                    self.placemark['name'] = data
                elif tag=='kml:description':
                    self.placemark['description'] = data
                elif tag=='kml:coordinates':
                    el = data.split(',')
                    for idx,val in enumerate(el):
                        try:
                            el[idx] = float(val)
                        except ValueError:
                            pass
                    self.placemark['coordinates'] = el
                elif tag=='dwd:value' and self.forecastelement:
                    if 'Forecast' not in self.placemark:
                        self.placemark['Forecast'] = dict()
                    el = data.split()
                    for idx,val in enumerate(el):
                        if val==self.mos.get('DefaultUndefSign',''):
                            el[idx] = None
                        else:
                            try:
                                vv = float(val)
                                if self.forecastelement in OBS_DICT:
                                    vv = OBS_DICT[self.forecastelement](vv)
                                el[idx] = vv
                            except ValueError:
                                pass
                    self.placemark['Forecast'][self.forecastelement] = el
            elif tag=='dwd:issuer':
                self.mos['Issuer'] = data
            elif tag=='dwd:productid':
                self.mos['ProductID'] = data
            elif tag=='dwd:generatingprocess':
                self.mos['GeneratingProcess'] = data
            elif tag=='dwd:issuetime':
                self.mos['IssueTime'] = KmlParser._mktime(data)
            elif tag=='dwd:defaultundefsign':
                self.mos['DefaultUndefSign'] = data
            elif tag=='dwd:timestep' and self.tags[-2]=='dwd:forecasttimesteps':
                if 'ForecastTimeSteps' not in self.mos:
                    self.mos['ForecastTimeSteps'] = []
                self.mos['ForecastTimeSteps'].append(KmlParser._mktime(data))
        if self.log_tags:
            print(self.lvl,self.tags,'data',data)
        
class DwdMosmix(object):

    def __init__(self, config_dict, verbose=False):
        # target path
        self.target_path = config_dict['DeutscherWetterdienst']['path']
        # forecast config data
        forecast_dict = config_dict['DeutscherWetterdienst']['forecast']
        # weather icons
        self.icon_pth = forecast_dict['icons']
        # logging
        self.verbose = verbose
        self.log_success = forecast_dict.get('log_success',config_dict['DeutscherWetterdienst'].get('log_success',config_dict.get('log_success',False)))
        self.log_failure = forecast_dict.get('log_failure',config_dict['DeutscherWetterdienst'].get('log_failure',config_dict.get('log_failure',False)))
        if int(config_dict.get('debug',0))>0 or verbose:
            self.log_success = True
            self.log_failure = True
            self.verbose = True
        if __name__ == "__main__" and verbose:
            print('-- configuration data ----------------------------------')
            print('log success:  ',self.log_success)
            print('log failure:  ',self.log_failure)
            print('target path:  ',self.target_path)
            print('--------------------------------------------------------')

    def download_kml(self, location, mosmix):

        url = get_mos_url(location,mosmix)
        
        headers={'User-Agent':'weewx-DWD'}
        reply = requests.get(url,headers=headers)
        
        if reply.status_code==200:
            if self.log_success or self.verbose:
                loginf('successfully downloaded %s' % reply.url)
            zz = zipfile.ZipFile(io.BytesIO(reply.content),'r')
            for ii in zz.namelist():
                if self.verbose:
                    loginf('-- %s --' % ii)
                return zz.read(ii).decode(encoding='utf-8')
            return None
        else:
            if self.log_failure or selg.verbose:
                logerr('error downloading %s: %s %s' % (reply.url,reply.status_code,reply.reason))
            return None
            
    def process_kml(self, text, log_tags=False):
        if self.verbose:
            loginf('processing KML file')
        parser = KmlParser(log_tags)
        parser.feed(text)
        parser.close()
        if self.verbose:
            loginf('KML file processed, %s placemarks found' % len(parser.mos.get('Placemark',[])))
        #print(json.dumps(parser.mos,indent=4,ensure_ascii=False))
        #print(parser.mos['Placemark'][0]['Forecast']['TTT'])
        return parser.mos

    @staticmethod
    def _temp_color(temp):
        """ temperature colors 
            Copyright (C) Tom O'Brien
        """
        if temp<=-17.78: return "#1278c8"
        if temp<=-3.8:   return "#30bfef"
        if temp<=0:      return "#1fafdd"
        if temp<=4.4:    return "rgba(0,172,223,1)"
        if temp<=10:     return "#71bc3c"
        if temp<=12.7:   return "rgba(90,179,41,0.8)"
        if temp<=18.3:   return "rgba(131,173,45,1)"
        if temp<=21.1:   return "rgba(206,184,98,1)"
        if temp<=23.8:   return "rgba(255,174,0,0.9)"
        if temp<=26.6:   return "rgba(255,153,0,0.9)"
        if temp<=29.4:   return "rgba(255,127,0,1)"
        if temp<=32.2:   return "rgba(255,79,0,0.9)"
        if temp<=35:     return "rgba(255,69,69,1)"
        if temp<=43.3:   return "rgba(255,104,104,1)"
        return "rgba(218,113,113,1)"
    
    def write_html(self, mos, obstypes, dryrun):
        s = ""
        s += '<table>'
        s += '<tr><td></td>'
        for ii in mos['ForecastTimeSteps']:
            ti = time.strftime('%d.%m.<br />%H:%M',time.localtime(ii*0.001))
            s += '<td>%s</td>' % ti
        s += '</tr>\n'
        for placemark in mos.get('Placemark'):
            obs = obstypes if obstypes else placemark['Forecast']
            for ii in obs:
                s += '<tr><td>%s</td>' % ii
                for jj in placemark['Forecast'][ii]:
                    s += '<td>%.1f</td>' % jj
                s += '</tr>\n'
        s += '</table>' 
        print(s)
        
    def write_html_daily(self, mos, obstypes, dryrun):
        OBS_LABEL = {
            'ww':('','',''),
            'TTTmin':('<i class="wi wi-thermometer">','Tmin','&deg;C'),
            'TTTmax':('<i class="wi wi-thermometer">','Tmax','&deg;C'),
            'TTTavg':('<i class="wi wi-thermometer">','Tavg','&deg;C'),
            'FFavg':('<i class="wi wi-strong-wind"></i>','Wind','km/h'),
            'DDavg':('<i class="wi wi-strong-wind"></i>','Windrichtung','&deg;'),
            'PPPPavg':('<i class="wi wi-barometer"></i>','Luftdruck','mbar'),
            'Navg':('<i class="wi wi-cloud"></i>','Bew&ouml;lkung','%'),
            'Neffavg':('<i class="wi wi-cloud"></i>','Bew&ouml;lkung','%'),
            'SunD1':('','SunD1','h'),
            'RSunD':('<i class="wi wi-day-sunny"></i>','Sonnenscheindauer','%'),
            'RR1c':('<i class="wi wi-umbrella"></i>','Niederschlag','mm'),
            'Rd10':('<i class="wi wi-umbrella"></i>','Wahrscheinlichkeit','%')}
        WEEKDAY = ['Mo','Di','Mi','Do','Fr','Sa','So']
        symbols = True
        desc = False
        for placemark in mos.get('Placemark'):
            days = dict()
            for idx,val in enumerate(mos['ForecastTimeSteps']):
                day = time.strftime('%d.%m.',time.localtime(val*0.001))
                vals = {ii:placemark['Forecast'][ii][idx] for ii in placemark['Forecast']}
                if day not in days: days[day] = { 'TTTmin':1000.0,'TTTmax':-273.15,'TTTsum':0.0,'count':0,'FFsum':0.0,'DDsum':0.0,'PPPPsum':0.0,'Nsum':0.0,'Neffsum':0.0,'SunD1':0.0,'RR1c':0.0,'ww':[] }
                days[day]['weekday'] = time.localtime(val*0.001).tm_wday
                days[day]['count'] += 1
                ttt = vals['TTT']
                days[day]['TTTsum'] += ttt
                if ttt>days[day]['TTTmax']: days[day]['TTTmax'] = ttt
                if ttt<days[day]['TTTmin']: days[day]['TTTmin'] = ttt
                for ii in ['FF','DD','PPPP','N','Neff']:
                    days[day][ii+'sum'] += vals[ii]
                days[day]['SunD1'] += vals['SunD1']/3600
                if vals['RSunD']: days[day]['RSunD'] = vals['RSunD']
                #try:
                #    rsun = placemark['Forecast']['RSunD'][idx+1]
                #    if rsun: days[day]['RSunD'] = rsun
                #    #print(idx,vals['RSunD'])
                #except (ValueError,IndexError):
                #    pass
                for ii in ['Rd00','Rd02','Rd10','Rd50']:
                    #if vals[ii]: days[day][ii] = vals[ii]
                    try:
                        xx = placemark['Forecast'][ii][idx+1]
                        if xx: days[day][ii] = xx
                        #if xx: print(idx,ii,xx)
                    except (ValueError,IndexError):
                        pass
                if vals['RR1c']: days[day]['RR1c'] += vals['RR1c']
                if vals['ww'] and vals['ww'] not in days[day]['ww']: days[day]['ww'].append(vals['ww'])
            for day in days:
                days[day]['TTTavg'] = days[day]['TTTsum']/days[day]['count']
                days[day]['FFavg'] = days[day]['FFsum']/days[day]['count']
                days[day]['DDavg'] = days[day]['DDsum']/days[day]['count']
                days[day]['PPPPavg'] = days[day]['PPPPsum']/days[day]['count']
                days[day]['Navg'] = days[day]['Nsum']/days[day]['count']
                days[day]['Neffavg'] = days[day]['Neffsum']/days[day]['count']
                wwcode = get_ww(days[day]['ww'],days[day]['Neffavg'],False)
                days[day]['icon'] = self.icon_pth+'/'+wwcode[4]
                days[day]['icontitle'] = wwcode[1]
            s = ""
            s += '<p><strong>%s</strong></p>\n' % placemark['description']
            s += '<table class="dwdforecasttable">'
            s += '<tr><td></td>'
            if symbols: s += '<td></td>'
            if desc: s += '<td></td>'
            for day in days:
                htmlclass = ' class="weekend"' if days[day]['weekday']>=5 else ''
                s += '<td%s><strong>%s</strong><br />%s</td>' % (htmlclass,WEEKDAY[days[day]['weekday']],day)
            s += '</tr>\n'
            obs = obstypes if obstypes else ['ww','TTTmax','TTTmin','FFavg','DDavg','RR1c','Rd10','PPPPavg','Neffavg','RSunD']
            for ii in obs:
                if ii=='ww':
                    s += '<tr class="icons">'
                elif ii in ['FFavg','PPPPavg','RR1c','Neffavg']:
                    s += '<tr class="topdist">'
                else:
                    s += '<tr>'
                color = ''
                prec_color = '#7cb5ec' if ii in ['RR1c','Rd00','Rd01','Rd05','Rd10'] else None
                if prec_color: color = ';color:%s' % prec_color
                if symbols:
                    s += '<td style="text-align:left%s" title="%s">%s' % (color,OBS_LABEL.get(ii,('',ii,''))[1],OBS_LABEL.get(ii,('',ii,''))[0])
                    if not desc and ii=='TTTmax': s+=' max'
                    if not desc and ii=='TTTmin': s+=' min'
                    s += '</td>'
                if desc:
                    s += '<td style="text-align:left%s">%s</td>' % (color,vOBS_LABEL.get(ii,('',ii,''))[1])
                if prec_color: color = ' style="color:%s"' % prec_color
                s += '<td'+color+'>'+OBS_LABEL.get(ii,('',ii,''))[2]+'</td>'
                dp = 1 if ii in ['TTTmin','TTTmax','TTTavg','SunD1'] else 0
                for day in days:
                    htmlclass = ' class="weekend"' if days[day]['weekday']>=5 else ''
                    try:
                        if ii=='ww':
                            #wwcode = get_ww(days[day]['ww'],days[day]['Neffavg'],False)
                            icontitle = days[day]['icontitle'].replace('ö','&ouml;').replace('ü','&uuml;')
                            s += '<td%s title="%s"><img src="%s" width="50px" alt="%s" /></td>' % (htmlclass,icontitle,days[day]['icon'],icontitle)
                        elif ii in ('DD','DDavg'):
                            #s += '<td%s><i class="fa fa-arrow-down" style="transform:rotate(%sdeg)"></i></td>' % (htmlclass,days[day][ii])
                            s += '<td%s><i class="wi wi-direction-down" style="transform:rotate(%sdeg);font-size:150%%"></i></td>' % (htmlclass,days[day][ii])
                        else:
                            color = ''
                            if ii[0:3]=='TTT': color = ' style="color:%s"' % DwdMosmix._temp_color(days[day][ii])
                            if prec_color: color = ' style="color:%s"' % prec_color
                            s += ('<td%s%s>%.*f</td>' % (htmlclass,color,dp,days[day].get(ii,float("NaN")))).replace('.',',')
                    except (ValueError,TypeError):
                        s += '<td>%s</td>' % days[day].get(ii,'')
                s += '</tr>\n'
            s += '</table>\n' 
            s += '<p style="font-size:85%%">herausgegeben vom <a href="https://www.dwd.de" target="_blank">DWD</a> am %s</p>\n' % time.strftime('%d.%m.%Y %H:%M',time.localtime(mos['IssueTime']/1000.0))
            fn = placemark['name']
            if dryrun:
                print(s)
            else:
                with open("%s/forecast-%s.inc" % (self.target_path,fn),"w") as file:
                    file.write(s)
                with open("%s/forecast-%s.json" % (self.target_path,fn),"w") as file:
                    json.dump(days,file,indent=4)

if __name__ == "__main__":

    usage = None

    epilog = """Station list:
https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/mosmix_stationskatalog.cfg?view=nasPublication&nn=16102
"""
    
    # Create a command line parser:
    parser = optparse.OptionParser(usage=usage, epilog=epilog)

    # options
    parser.add_option("--config", dest="config_path", type=str,
                      metavar="CONFIG_FILE",
                      default=None,
                      help="Use configuration file CONFIG_FILE.")
    parser.add_option("--weewx", action="store_true",
                      help="Read config from weewx.conf.")

    group = optparse.OptionGroup(parser,"Output and logging options")
    group.add_option("--dry-run", action="store_true",
                      help="Print what would happen but do not do it. Default is False.")
    group.add_option("--log-tags", action="store_true",
                      help="Log tags while parsing the KML file.")
    group.add_option("-v","--verbose", action="store_true",
                      help="Verbose output")
    parser.add_option_group(group)

    (options, args) = parser.parse_args()

    if options.weewx:
        config_path = "/etc/weewx/weewx.conf"
    else:
        config_path = options.config_path

    if config_path:
        print("Using configuration file %s" % config_path)
        config = configobj.ConfigObj(config_path)
    else:
        # test only
        print("Using test configuration")
        config = {
            'DeutscherWetterdienst': {
                'path':'/etc/weewx/skins/Belchertown1_3/dwd',
                'forecast':{
                    'icons':'./weewx/belchertown/images'}}}
    
    if len(args)>0:
        location = args[0]
        if not location: location = None
    else:
        location = 'Döbeln'
        
    dwd = DwdMosmix(config,options.verbose)
    zz = dwd.download_kml(location,'l')
    mos = dwd.process_kml(zz,options.log_tags)
    #dwd.write_html(mos,['TTT','PPPP','DD','FF'],True)
    dwd.write_html_daily(mos,None,options.dry_run)
    
     